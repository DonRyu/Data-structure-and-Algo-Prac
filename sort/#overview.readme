
#1 세가지 다 비슷함, 작은 규모에서 잘 작동함
Bubble: 두개씩 비교 하면서 큰값을 오른쪽으로 보냄 
o(n^2)
Selection: 순회 하면서 나머지 값들중 제일 작은 값을 비교하는 인덱스랑 바꿈(제일 느림)
o(n^2) 
Insertion: 오른쪽에 있는 값이랑 바꿔 나가는데 바뀐 값이 뒤에 값들과 또 비교 하면서 적은값을 왼쪽으로 보냄, 실시간으로 들어 오는 데이터를 재배치 하는데 효과적
o(n^2) 

#2
Merge: divide and conquer, 
o(nlogn)
스페이스 컴플렉시티가 o(n)임, 왜냐면 어레이가 클수록 더 많이 나눠야됨

배열의 한 요소를 기준으로(피벗, Pivot) 배열을 두 개의 하위 배열로 분할합니다.
피벗보다 작은 요소는 피벗의 왼쪽 하위 배열에, 큰 요소는 오른쪽 하위 배열에 배치합니다.
각 하위 배열에 대해 위의 과정을 재귀적으로 반복합니다.
각 하위 배열의 정렬이 완료되면, 이를 합쳐 정렬된 배열을 얻습니다.

Quick: divide and conquer,  
o(nlogn)
이미 정렬된 어레이의 경우 o(n^2)가 되어 버림, 정렬이 되어 있음으로 항상 같은쪽으로 분할됨 

배열을 반으로 나누어 두 개의 하위 배열로 분할합니다.
각 하위 배열에 대해 위의 과정을 재귀적으로 반복합니다.
하위 배열의 크기가 1이 될 때까지 분할을 반복합니다.
분할된 하위 배열을 병합하여 정렬된 하나의 배열을 만듭니다.